--- a/prisma-to-ts-generator/src/ast-processor.ts
+++ b/prisma-to-ts-generator/src/ast-processor.ts
@@ -3,7 +3,7 @@
 import { FieldDef, ModelDef, EnumDef } from './types';
 
 const processField = (p: any): FieldDef => ({
-    name: p.name,
+    name: p.name,    isUnique: !!(p.attributes || []).find((attr: any) => attr.name === 'unique'),
     type: typeof p.fieldType === 'string' ? p.fieldType : p.fieldType.name,
     isArray: !!p.array,
     isOptional: !!p.optional || (p.attributes || []).some((attr: any) => attr.name === 'nullable'),
@@ -30,7 +30,7 @@
 };
 
 export const findDirectoryByName = async (baseDir: string, dirName: string): Promise<string | null> => {
-    try {
+    try {        const entries = await fsPromises.readdir(baseDir);
         const entries = await fsPromises.readdir(baseDir);
         for (const entry of entries) {
             const fullEntryPath = path.join(baseDir, entry);
@@ -78,7 +78,7 @@
     allEnums.forEach(enumDef => { indexContent += generateEnum(enumDef, outDir, multiFiles, resolvedEnumDirPath); });
 
     [...allTypes, ...allModels].forEach(model => {
-        const variants = (modelVariants || ['Regular']) as VariantType[];
+        const variants = (modelVariants || ['Regular']) as VariantType[];        variants.forEach(variant => {
         variants.forEach(variant => {
             indexContent += generateModel(model, allModels, allEnums, allTypes, outDir, multiFiles, hasHelperTypes, variant, modelVariants, resolvedModelDirPath, resolvedEnumDirPath, resolvedHelperDirPath);
         });
@@ -90,6 +90,7 @@
 ```ts prisma-to-ts-generator/src/helper-types.ts
 // helper-types.ts
 import { Prisma } from '@prisma/client';
+export type NullableStringInput = string | null | 'DbNull';
 
 export type NullableJsonInput = Prisma.JsonValue | null | 'JsonNull' | 'DbNull' | Prisma.NullTypes.DbNull | Prisma.NullTypes.JsonNull;
 export const transformJsonNull = (v?: NullableJsonInput) => {
@@ -111,7 +112,7 @@
 ```ts prisma-to-ts-generator/src/index.ts
 // index.ts
 export { generate } from './generator';
-export * from './types'; // Optionally export types for external use
+export * from './types';

@@ -19,7 +20,7 @@
const generateEnumContent = (enumDef: EnumDef): string =>
    `export type ${enumDef.name} = ${enumDef.values.map(v => `'${v}'`).join(' | ')};\n`;

-export type VariantType = 'CreateInput' | 'UpdateInput' | 'Partial' | 'Regular';
+export type VariantType = 'CreateInput' | 'UpdateInput' | 'Partial' | 'Regular' | 'WhereUniqueInput' | 'WhereInput' | 'CreateArgs' | 'UpdateArgs' | 'DeleteArgs' | 'FindUniqueArgs' | 'FindFirstArgs' | 'FindManyArgs' | 'ConnectOrCreateInput';

 const generateModelFieldsContent = (
     model: ModelDef, allModels: ModelDef[], enums: EnumDef[], types: ModelDef[],
@@ -35,6 +36,7 @@
        'Partial': (_field: FieldDef) => true,
        'Regular': (_field: FieldDef) => true,
        'WhereUniqueInput': (field: FieldDef) => field.isUnique,
+        'ConnectOrCreateInput': (_field: FieldDef) => false, // ConnectOrCreateInput doesn't directly use fields
        'WhereInput': (_field: FieldDef) => true,
    };
    const optionalModifier: Record<VariantType, (field: FieldDef) => string> = {
@@ -43,6 +45,7 @@
        'Partial': (_field: FieldDef) => '?',
        'Regular': (field: FieldDef) => field.isOptional ? '?' : '',
        'WhereUniqueInput': (_field: FieldDef) => '',
+        'ConnectOrCreateInput': (_field: FieldDef) => '', // Not applicable for ConnectOrCreateInput
        'WhereInput': (_field: FieldDef) => '?',
        'CreateArgs': (_field: FieldDef) => '', // Args types don't use optional modifier on fields
        'UpdateArgs': (_field: FieldDef) => '',
@@ -57,6 +60,7 @@
        'Partial': (_field: FieldDef) => '',
        'Regular': (field: FieldDef) => variant !== 'Partial' && field.isOptional ? ' | null' : '',
        'WhereUniqueInput': (_field: FieldDef) => '',
+        'ConnectOrCreateInput': (_field: FieldDef) => '', // Not applicable for ConnectOrCreateInput
        'WhereInput': (_field: FieldDef) => ' | null',
        'CreateArgs': (_field: FieldDef) => '', // Args types don't use null modifier on fields
        'UpdateArgs': (_field: FieldDef) => '',
@@ -113,15 +117,24 @@

    const variantName = variant === 'Regular' ? model.name : `${model.name}${variant}`;
    let variantContent = '';
-    if (['Partial', 'CreateInput', 'UpdateInput', 'WhereUniqueInput', 'WhereInput', 'CreateArgs', 'UpdateArgs', 'DeleteArgs', 'FindUniqueArgs', 'FindFirstArgs', 'FindManyArgs'].includes(variant)) {
+    if (['Partial', 'CreateInput', 'UpdateInput', 'WhereUniqueInput', 'WhereInput', 'CreateArgs', 'UpdateArgs', 'DeleteArgs', 'FindUniqueArgs', 'FindFirstArgs', 'FindManyArgs', 'ConnectOrCreateInput'].includes(variant)) {
        const baseTypeName = model.name;
        const omitFields = "'id' | 'createdAt' | 'updatedAt'";
        const requiredFields = model.fields.filter(f => !f.isOptional && !autoGeneratedFields.includes(f.name)).map(f => `'${f.name}'`).join(' | ');
        const uniqueFieldsTypeName = `${model.name}WhereUniqueInput`;
        const whereInputName = `${model.name}WhereInput`;
+        const createInputName = `${model.name}CreateInput`;
        const whereInputTypeName = `${model.name}WhereInput`;
        const createInputTypeName = `${model.name}CreateInput`;
        const updateInputTypeName = `${model.name}UpdateInput`;
+        const connectOrCreateInputName = `${model.name}ConnectOrCreateInput`;
+
+        const generateConnectOrCreateType = (field: FieldDef): string => {
+            const fieldTypeName = getTsType(field.type, field, model, allModels, enums, types, imports, multiFiles);
+            const relatedModel = allModels.find(m => m.name === fieldTypeName) || types.find(t => t.name === fieldTypeName);
+            if (!relatedModel) return ''; // Skip if related model/type not found (shouldn't happen in valid schema)
+            return `{\n      where: ${fieldTypeName}WhereUniqueInput;\n      create: ${fieldTypeName}CreateInput;\n    }`;
+        };
        variantContent = `export type ${variantName} = ${
            variant === 'WhereInput' ? `{\n  AND?: ${whereInputName} | ${whereInputName}[];\n  OR?: ${whereInputName}[];\n  NOT?: ${whereInputName};\n} & Partial<${baseTypeName}>`
            variant === 'WhereUniqueInput' ? `Pick<${baseTypeName}, ${model.fields.filter(f => f.isUnique).map(f => `'${f.name}'`).join(' | ')}>`
@@ -131,6 +144,9 @@
            : variant === 'FindUniqueArgs' ? { where: `${uniqueFieldsTypeName}` }
            : variant === 'FindFirstArgs' ? { where: `${whereInputTypeName}` }
            : variant === 'FindManyArgs' ? { where: `${whereInputTypeName}` }
+            : variant === 'ConnectOrCreateInput' ? `{\n${model.fields
+                  .filter(field => allModels.find(m => m.name === field.type) || types.find(t => t.name === field.type)) // Only relation fields
+                  .map(field => `  ${field.name}?: ${generateConnectOrCreateType(field)};`) // Generate connectOrCreate for relation fields
+                  .join('\n')}\n  }`
        };\n`;
    } else {
        variantContent = `export interface ${variantName} ${fieldsContent ? `{\n${fieldsContent}\n}` : `{}`}\n`;
@@ -140,7 +156,7 @@
```ts prisma-to-ts-generator/src/type-mapping.ts
// type-mapping.ts
import { FieldDef, ModelDef, EnumDef } from './types';
-
+``
export const typeMap: Record<string, string> = {
    String: 'string', Decimal: 'DecimalJsLike', Int: 'number', Float: 'number',
    Boolean: 'boolean', DateTime: 'Date', Json: 'JsonValueType', Bytes: 'Buffer', BigInt: 'bigint',
@@ -165,7 +181,7 @@
```ts prisma-to-ts-generator/src/types.ts
import { VariantType } from "./ts-generator";

-export interface FieldDef { name: string; type: string; isArray: boolean; isOptional: boolean; comment?: string; }
+export interface FieldDef { name: string; type: string; isArray: boolean; isOptional: boolean; comment?: string;  isUnique: boolean;}
 export interface ModelDef { name: string; fields: FieldDef[]; isType: boolean; comments: string[]; }
 export interface EnumDef { name: string; values: string[]; }
 export interface GeneratorConfig { dirOrFilesPath: string[]; outputPath: string; multiFiles: boolean; modelVariants?: VariantType[]; }
EOF