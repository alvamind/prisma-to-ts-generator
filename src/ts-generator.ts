// ts-generator.ts
import path from 'path';
import { ModelDef, EnumDef, GeneratorConfig, FieldDef } from './types';
import { getTsType } from './type-mapping';
import { writeFile, resolveDirPath } from './file-utils';

const generateEnumContent = (enumDef: EnumDef): string =>
    `export type ${enumDef.name} = ${enumDef.values.map(v => `'${v}'`).join(' | ')};\n`;

export type VariantType = 'CreateInput' | 'UpdateInput' | 'Partial' | 'Regular';

const generateModelFieldsContent = (
    model: ModelDef, allModels: ModelDef[], enums: EnumDef[], types: ModelDef[],
    imports: Set<string>, multiFiles: boolean, variant: VariantType
): string => {
    const autoGeneratedFields = ['id', 'createdAt', 'updatedAt'];
    const fieldMap: Record<VariantType, (field: FieldDef) => boolean> = {
        'CreateInput': (field: FieldDef) => !autoGeneratedFields.includes(field.name),
        'UpdateInput': (_field: FieldDef) => true,
        'Partial': (_field: FieldDef) => true,
        'Regular': (_field: FieldDef) => true,
    };
    const optionalModifier: Record<VariantType, (field: FieldDef) => string> = {
        'CreateInput': (field: FieldDef) => field.isOptional ? '?' : '',
        'UpdateInput': (_field: FieldDef) => '?',
        'Partial': (_field: FieldDef) => '?',
        'Regular': (field: FieldDef) => field.isOptional ? '?' : '',
    };
    const nullModifier: Record<VariantType, (field: FieldDef) => string> = {
        'CreateInput': (_field: FieldDef) => '',
        'UpdateInput': (_field: FieldDef) => ' | null',
        'Partial': (_field: FieldDef) => '',
        'Regular': (field: FieldDef) => variant !== 'Partial' && field.isOptional ? ' | null' : '',
    };

    return model.fields
        .filter(fieldMap[variant])
        .map(field => {
            let tsType = getTsType(field.type, field, model, allModels, enums, types, imports, multiFiles);
            if (field.isArray) tsType += '[]';
            const optional = optionalModifier[variant](field);
            const nullable = nullModifier[variant](field);
            const commentLine = field.comment ? `  ${field.comment}\n` : '';
            return `${commentLine}  ${field.name}${optional}: ${tsType}${nullable};`;
        }).join('\n');
};


const generateModelVariantContent = (
    model: ModelDef, fieldsContent: string, variant: VariantType, imports: Set<string>,
    multiFiles: boolean, resolvedHelperDirPath: string, modelFilePath: string
): { content: string, importStatements: string }  => { // Return importStatements
    let helperImports = '';
    const needsDecimal = model.fields.some(f => f.type === 'Decimal');
    const needsJson = model.fields.some(f => f.type === 'Json');
    const autoGeneratedFields = ['id', 'createdAt', 'updatedAt'];
    let importStatements = '';

    if (multiFiles) {
        const importStatementsArray = Array.from(imports).map(originalImportPath => {
            const [typeDir, importName] = originalImportPath.split('/');
            const targetDirPath = resolveDirPath('', path.join('output', typeDir));
            const targetFilePath = path.join(targetDirPath, `${importName}.ts`);
            const relativePath = path.relative(path.dirname(modelFilePath), targetFilePath).replace(/\\/g, '/');
            return `import type { ${importName} } from '${relativePath.startsWith('.') ? relativePath : './' + relativePath}';`;
        });

        const helperTypesFilePath = path.join(resolvedHelperDirPath, 'helper-types.ts');
        const relativeHelperPath = path.relative(path.dirname(modelFilePath), helperTypesFilePath).replace(/\\/g, '/');
        helperImports = [
            needsDecimal ? `import type { DecimalJsLike } from '${relativeHelperPath.startsWith('.') ? relativeHelperPath : './' + relativeHelperPath}';` : '',
            needsJson ? `import type { JsonValueType } from '${relativeHelperPath.startsWith('.') ? relativeHelperPath : './' + relativeHelperPath}';` : '',
        ].filter(Boolean).join('\n');
        importStatements = `${helperImports}\n${importStatementsArray.join('\n')}`;
    }

    const variantName = variant === 'Regular' ? model.name : `${model.name}${variant}`;
    let variantContent = ''; // Declare here
    if (['Partial', 'CreateInput', 'UpdateInput'].includes(variant)) {
        const baseTypeName = model.name;
        const omitFields = "'id' | 'createdAt' | 'updatedAt'";
        const requiredFields = model.fields.filter(f => !f.isOptional && !autoGeneratedFields.includes(f.name)).map(f => `'${f.name}'`).join(' | ');
        variantContent = `export type ${variantName} = ${
            variant === 'Partial' ? `Partial<${baseTypeName}>`
            : variant === 'CreateInput' ? `Omit<${baseTypeName}, ${omitFields}> ${requiredFields ? `& Required<Pick<${baseTypeName}, ${requiredFields}>>` : ''}`
            : `Partial<${baseTypeName}>`
        };\n`;
    } else {
        variantContent = `export interface ${variantName} ${fieldsContent ? `{\n${fieldsContent}\n}` : `{}`}\n`;
    }
    return { content: variantContent, importStatements }; // Return both
};

export const generateModel = (
    model: ModelDef, allModels: ModelDef[], enums: EnumDef[], types: ModelDef[],
    outDir: string, multiFiles: boolean, needsHelperTypes: boolean, variant: VariantType, modelVariants: string[] | undefined,
    resolvedModelDirPath: string, resolvedEnumDirPath: string, resolvedHelperDirPath: string
): string => {
    const imports = new Set<string>();
    const modelOutputDir = resolvedModelDirPath;
    const modelFilePath = path.join(modelOutputDir, `${model.name}.ts`);
    let content = model.comments?.map(c => `/// ${c}\n`).join('') || '';

    const fieldsContent = generateModelFieldsContent(model, allModels, enums, types, imports, multiFiles, variant);
    const variantGenResult = generateModelVariantContent(model, fieldsContent, variant, imports, multiFiles, resolvedHelperDirPath, modelFilePath); // Capture result
    const variantContent = variantGenResult.content;
    const importStatements = variantGenResult.importStatements; // Extract importStatements


    if (multiFiles) {
        let fileContentToWrite = '';
        if (modelVariants && modelVariants.includes('Regular')) {
            const regularVariantGenResult = generateModelVariantContent(model, generateModelFieldsContent(model, allModels, enums, types, new Set(), multiFiles, 'Regular'), 'Regular', new Set(), multiFiles, resolvedHelperDirPath, modelFilePath);
            fileContentToWrite += regularVariantGenResult.content + '\n';
        }
        if (modelVariants && modelVariants.includes('Partial')) {
            const partialVariantGenResult = generateModelVariantContent(model, '', 'Partial', new Set(), multiFiles, resolvedHelperDirPath, modelFilePath);
            fileContentToWrite += partialVariantGenResult.content + '\n';
        }
        if (modelVariants && modelVariants.includes('CreateInput')) {
            const createInputVariantGenResult = generateModelVariantContent(model, generateModelFieldsContent(model, allModels, enums, types, new Set(), multiFiles, 'CreateInput'), 'CreateInput', new Set(), multiFiles, resolvedHelperDirPath, modelFilePath);
            fileContentToWrite += createInputVariantGenResult.content + '\n';
        }
        if (modelVariants && modelVariants.includes('UpdateInput')) {
            const updateInputVariantGenResult = generateModelVariantContent(model, generateModelFieldsContent(model, allModels, enums, types, new Set(), multiFiles, 'UpdateInput'), 'UpdateInput', new Set(), multiFiles, resolvedHelperDirPath, modelFilePath);
            fileContentToWrite += updateInputVariantGenResult.content + '\n';
        }

        writeFile(modelFilePath, `${variant === 'Regular' ? importStatements.trim() + '\n' : ''}${content}${fileContentToWrite}`); // Use captured importStatements
        return '';
    }

    return `${content}${variantContent}`;
};


export const generateEnum = (
    enumDef: EnumDef, outDir: string, multiFiles: boolean, resolvedEnumDirPath: string
): string => {
    const content = generateEnumContent(enumDef);
    if (multiFiles) {
        const enumOutputDir = resolvedEnumDirPath;
        const enumFilePath = path.join(enumOutputDir, `${enumDef.name}.ts`);
        writeFile(enumFilePath, content);
        return '';
    }
    return content;
};
