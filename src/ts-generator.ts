// prisma-to-ts-generator/src/ts-generator.ts
import path from 'path';
import { ModelDef, EnumDef, GeneratorConfig, FieldDef, VariantType } from './types';
import { getTsType } from './type-mapping';
import { writeFile, resolveOutputPath } from './file-utils';

const generateEnumContent = (enumDef: EnumDef): string =>
    `export type ${enumDef.name} = ${enumDef.values.map(v => `'${v}'`).join(' | ')};\n`;

const generateModelFieldsContent = (
    model: ModelDef, allModels: ModelDef[], enums: EnumDef[], types: ModelDef[],
    imports: Set<string>, multiFiles: boolean, variant: VariantType
): string => {
    const autoGeneratedFields = ['id']; // Reduced to only 'id'
    const fieldMap: Record<VariantType, (field: FieldDef) => boolean> = {
        'CreateInput': (field: FieldDef) => !field.isPrimaryKey && !autoGeneratedFields.includes(field.name), // Still omit primary key and 'id'
        'UpdateInput': (_field: FieldDef) => true,
        'Partial': (_field: FieldDef) => true,
        'Regular': (_field: FieldDef) => true,
    };
    const optionalModifier: Record<VariantType, (field: FieldDef) => string> = {
        'CreateInput': (field: FieldDef) => field.isOptional ? '?' : '',
        'UpdateInput': (_field: FieldDef) => '?',
        'Partial': (_field: FieldDef) => '?',
        'Regular': (field: FieldDef) => field.isOptional ? '?' : '',
    };
    const nullModifier: Record<VariantType, (field: FieldDef) => string> = {
        'CreateInput': (_field: FieldDef) => '',
        'UpdateInput': (_field: FieldDef) => ' | null',
        'Partial': (_field: FieldDef) => '',
        'Regular': (field: FieldDef) => variant !== 'Partial' && field.isOptional ? ' | null' : '',
    };

    return model.fields
        .filter(fieldMap[variant])
        .map(field => {
            let tsType = getTsType(field.type, field, model, allModels, enums, types, imports, multiFiles);
            if (field.isArray) tsType += '[]';
            const optional = optionalModifier[variant](field);
            const nullable = nullModifier[variant](field);
            const commentLine = field.comment ? `  ${field.comment}\n` : '';
            return `${commentLine}  ${field.name}${optional}: ${tsType}${nullable};`;
        }).join('\n');
};

const generateModelVariantContent = (
    model: ModelDef, fieldsContent: string, variant: VariantType, imports: Set<string>,
    multiFiles: boolean, resolvedHelperDirPath: string, modelFilePath: string, resolvedOutputPath: string
): { content: string, importStatements: string } => {
    let helperImports = '';
    const needsDecimal = model.fields.some(f => f.type === 'Decimal');
    const needsJson = model.fields.some(f => f.type === 'Json');
    const autoGeneratedFields = ['id']; // Reduced to only 'id'
    let importStatements = '';

    if (multiFiles) {
        // Modify the importStatementsArray mapping in generateModelVariantContent function
        const importStatementsArray = Array.from(imports).map(originalImportPath => {
            const [typeDir, importName] = originalImportPath.split('/');
            let relativePath;
            if (typeDir === 'enum') {
                relativePath = `../enum/${importName}`;
            } else if (typeDir === 'model') {
                relativePath = `./${importName}`;
            } else {
                relativePath = `./${importName}`; // default case, though unlikely
            }
            return `import type { ${importName} } from '${relativePath}';`;
        });

        const helperTypesFilePath = path.join(resolvedHelperDirPath, 'helper-types.ts');
        const relativeHelperPath = path.relative(path.dirname(modelFilePath), helperTypesFilePath)
            .replace(/\\/g, '/')
            .replace(/\.ts$/, ''); // Remove .ts extension
        helperImports = [
            needsDecimal ? `import type { DecimalJsLike } from '${relativeHelperPath.startsWith('.') ? relativeHelperPath : './' + relativeHelperPath}';` : '',
            needsJson ? `import type { JsonValueType } from '${relativeHelperPath.startsWith('.') ? relativeHelperPath : './' + relativeHelperPath}';` : '',
        ].filter(Boolean).join('\n');
        importStatements = `${helperImports}\n${importStatementsArray.join('\n')}`;
    }

    const variantName = variant === 'Regular' ? model.name : `${model.name}${variant}`;
    let variantContent = '';
    if (['Partial', 'CreateInput', 'UpdateInput'].includes(variant)) {
        const baseTypeName = model.name;
        const omitFields = "'id'"; // Now only omit 'id'
        const requiredFields = model.fields.filter(f => !f.isOptional && !autoGeneratedFields.includes(f.name) && !f.isPrimaryKey).map(f => `'${f.name}'`).join(' | '); // Ensure primary keys and 'id' are not required
        variantContent = `export type ${variantName} = ${
            variant === 'Partial' ? `Partial<${baseTypeName}>`
                : variant === 'CreateInput' ? `Omit<${baseTypeName}, ${omitFields}> ${requiredFields ? `& Required<Pick<${baseTypeName}, ${requiredFields}>>` : ''}`
                    : `Partial<${baseTypeName}>`
            };\n`;
    } else {
        variantContent = `export interface ${variantName} ${fieldsContent ? `{\n${fieldsContent}\n}` : `{}`}\n`;
    }

    return { content: variantContent, importStatements };
};

export const generateModel = (
    model: ModelDef, allModels: ModelDef[], enums: EnumDef[], types: ModelDef[],
    outDir: string, multiFiles: boolean, needsHelperTypes: boolean, variant: VariantType, modelVariants: string[] | undefined,
    resolvedModelDirPath: string, resolvedEnumDirPath: string, resolvedHelperDirPath: string
): string => {
    const imports = new Set<string>();
    const modelOutputDir = resolvedModelDirPath;
    const modelFilePath = path.join(modelOutputDir, `${model.name}.ts`);
    let content = model.comments?.map(c => `/// ${c}\n`).join('') || '';
    let allVariantsFileContent = '';
    let combinedImportStatements = '';
    const resolvedOutputPath = resolveOutputPath(outDir);

    if (multiFiles) {
        const variantsToGenerate = (modelVariants || ['Regular']) as VariantType[];

        variantsToGenerate.forEach(currentVariant => {
            const fieldsContent = generateModelFieldsContent(model, allModels, enums, types, imports, multiFiles, currentVariant as VariantType);
            const variantGenResult = generateModelVariantContent(model, fieldsContent, currentVariant as VariantType, imports, multiFiles, resolvedHelperDirPath, modelFilePath, resolvedOutputPath);
            allVariantsFileContent += variantGenResult.content + '\n';
            combinedImportStatements = variantGenResult.importStatements;
        });

        writeFile(modelFilePath, `${combinedImportStatements.trim() + '\n'}${content}${allVariantsFileContent}`);
        return '';
    }

    const fieldsContent = generateModelFieldsContent(model, allModels, enums, types, imports, multiFiles, variant);
    const variantGenResult = generateModelVariantContent(model, fieldsContent, variant, imports, multiFiles, resolvedHelperDirPath, modelFilePath, resolvedOutputPath);
    const variantContent = variantGenResult.content;
    return `${content}${variantContent}`;
};

export const generateEnum = (
    enumDef: EnumDef, outDir: string, multiFiles: boolean, resolvedEnumDirPath: string
): string => {
    const content = generateEnumContent(enumDef);
    if (multiFiles) {
        const enumOutputDir = resolvedEnumDirPath;
        const enumFilePath = path.join(enumOutputDir, `${enumDef.name}.ts`);
        writeFile(enumFilePath, content);
        return '';
    }
    return content;
};
